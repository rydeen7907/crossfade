＝＝＝＝＝

クロスフェードっていうやつ

2024.11.10 ver1.0
2024.11.11 ver1.5 "morphing"と記載されたコードを"crossed"に変更しました。
2024.11.16 ver2.0 顔検出できた場合("crossed_faces"フォルダ)と、できなかった場合("crossed_images"フォルダ)に分類しました。
                  各フォルダに保存された画像を動画に変換するコードを追加しました。

＝＝＝＝＝

1. 任意の画像を保存します: 
img1 と img2 に、クロスフェードしたい2つの画像を保存してください。 
画像には顔が含まれている必要があります。
コードを実行します: このコードをPythonスクリプトとして保存し、実行します。

2. faces1 = face_cascade.detectMultiScale(gray1, 1.1, 4)
detectMultiScale関数のパラメータには、画像のグレースケール版、スケールファクター、最小サイズを指定します。
・1.1は、スケールファクター（scale factor）です。スケールファクターは、
画像をスケールアップまたはスケールダウンするために使用されます。この場合、1.1は、画像を10%スケールアップすることを意味します。
・4は、最小隣接領域（minNeighbors）です。最小隣接領域は、検出された領域が何回繰り返される必要があるかを指定します。
この場合、4は、検出された領域が少なくとも4回繰り返される必要があることを意味します。
つまり、このコードは、画像gray1から顔検出を行い、スケールファクターを1.1、最小隣接領域を4として設定しています。

・1.1を小さくする（例: 1.05）:
顔検出の精度が上がる
顔検出の速度が遅くなる
小さな顔も検出される
・1.1を大きくする（例: 1.2）:
顔検出の精度が下がる
顔検出の速度が速くなる
大きな顔のみが検出される

・4を小さくする（例: 2）:
顔検出の精度が下がる
顔検出の速度が速くなる
顔検出の誤検出が増える
・4を大きくする（例: 6）:
顔検出の精度が上がる
顔検出の速度が遅くなる
顔検出の誤検出が減る
つまり、1.1と4の値を調整することで、顔検出の精度と速度のバランスを取ることができます。

3. クロスフェードされた画像が表示されます: コードは、2つの顔画像をクロスフェードした画像を段階的に表示します。
説明:
このコードはOpenCVライブラリを使用し、2つの画像の顔のクロスフェードを行います。
まず、画像を読み込み、グレースケールに変換し、サイズを調整します。
次に、Haarcascadeを使用して顔検出を行い、最初の顔の座標を取得します。
顔の画像を切り取り、同じサイズにリサイズします。
アルゴリズムは、cv2.addWeighted() 関数を使用して2つの顔画像をブレンドします。 
これは、アルファ値を0から1まで徐々に変化させることによって行われます。
アルファ値は、画像のブレンドに使用する各顔の割合を制御します。 
アルファ値が0の場合、最初の顔が完全に表示され、アルファ値が1の場合、2番目の顔が完全に表示されます。

追加のヒント:
クロスフェード効果を調整するには、alpha と beta の値を変更してください。 
<<<<<<< HEAD
=======

効果を調整するには、alpha と beta の値を変更してください。 
>>>>>>> 07483842fa517c05a8c4e2a332271d9be85b897e
alpha は最初の画像の重みを表し、beta は2番目の画像の重みを表します。
よりスムーズなクロスフェードを実現するために、より多くの段階を含めることができます。 
例えば、range(0, 21) を使用して、20段階でクロスフェードを実行できます。
cv2.waitKey() 関数を使用して、各段階の表示時間を調整できます。 
例えば、cv2.waitKey(500) を使用すると、各段階が0.5秒間表示されます。
このコードは、画像全体をクロスフェードするための基本的な例です。 
より高度な画像モーフィングアルゴリズムを使用するには、OpenCVドキュメントを参照してください。

4. クロスフェードされた画像を保存します:
cv2.imwrite() 関数を使用して、クロスフェードされた画像をファイルに保存しています。
ファイル名は crossed_image_{i}.jpg のように、各画像の番号が付けられています。
これで、モーフィングされた画像が crossed_image_0.jpg から crossed_image_{i}.jpg までのファイルとして保存されます。

顔が検出された場合："crossed_faces"フォルダに、グレースケールに変換されたクロスフェード画像が保存され、
検出されなかった場合："crossed_images"フォルダに、そのままクロスフェードされた画像が保存される仕様になっています。

注意:
ファイル名に f を付けているのは、f-string を使用しているためです。 
f-string を使用すると、変数を文字列の中に埋め込むことができます。
cv2.imshow() 関数は、クロスフェードされた画像を表示するために使用されていますが、これはオプションです。
画像を保存する前に、適切なフォルダが存在することを確認してください。

コード内で調整可能な部分を変更することで、お好みのクロスフェード効果を調整することができます。

5. 動画の作成:
・image_folder 変数に画像が格納されているフォルダを指定します。
・video_name 変数に作成する動画ファイル名を設定します。
・os.listdir で画像ファイルのリストを取得し、images に格納します。
・images.sort() で画像名をソートします。

最初のフレームを読み込み、高さ、幅、チャンネル数を取得します。
cv2.VideoWriter を使用して動画ライターを作成します。引数は次の通りです:
video_name: 作成する動画ファイル名。
cv2.VideoWriter_fourcc(*'XVID'): コーデック。
12: フレームレート (fps)。
(width, height): 動画のサイズ。

6. 動画への書き込み:
・for ループで画像ファイルを順番に読み込みます。
・video.write() メソッドで各フレームを動画に書き込みます。
クリーンアップ:
・cv2.destroyAllWindows() でウィンドウを閉じます。
・video.release() で動画ライターを解放します。
このコードを実行すると、crossed_faces フォルダ内の画像から crossed_faces.mp4 という動画ファイルが作成されます。

注意:画像がソートされていないと、動画が意図した順番にならない可能性があります。 コード内でソート処理は正しく行われているのですが、os.listdir が返すファイル名のリストが必ずしもソートされた状態ではないため、問題が発生している可能性があります。

sorted 関数: 
images を取得する際に、sorted 関数を使ってファイル名をソートします。
key=lambda x: int(x.split('_')[1].split('.')[0]): ソートキーとして、
ファイル名から数字部分だけを取り出して整数に変換するラムダ式を使用します。これにより、数字の昇順でファイル名をソートできます。
この変更を加えることで、画像が数字の順番で動画に正しく組み込まれるようになります。

変更点:
re.search(r'\d+', x).group(): re.search を使用してファイル名から数字部分だけを抽出します。
r'\d+' は、数字の1つ以上の連続する文字列にマッチする正規表現です。group() メソッドは、マッチした数字部分を文字列として返します。
これで、ファイル名に "crossed_faces_" のような文字列が含まれていても、
数字部分だけを正しく取り出してソートできるようになり、動画を作成できます。
<<<<<<< HEAD

7. 画像や動画の場合、アルファ値とベータ値は少し異なる意味を持ちます。

画像におけるアルファ値：
画像において、アルファ値はピクセルの不透明度を表します。
値の範囲は通常0から255または0から1で、0は完全に透明、255または1は完全に不透明を表します。
アルファ値を使用することで、画像の背景を透かしたり、画像を重ねて表示したりすることができます。

動画におけるアルファ値：
動画におけるアルファ値も画像と同様に、フレーム内のピクセルの不透明度を表します。
動画編集ソフトでは、アルファ値を使ってトランジション効果を作成したり、複数の動画を重ねて表示したりすることができます。

※画像や動画におけるベータ値：
画像や動画において、「ベータ値」という概念は一般的ではありません。
画像処理やコンピュータビジョンにおいて、「ベータ」という用語は他の意味で使われることがありますが、
アルファ値のように明確に定義されたものではありません。

8. "Escキー"を押すと強制終了することが可能です。
=======

cv2.imshow() 関数は,クロスフェードされた画像を表示するために使用されていますが、これはオプションです。
画像を保存する前に、適切なフォルダが存在することを確認してください。

※ より高度な画像アルゴリズムを使用するには、OpenCVドキュメントを参照してください。
>>>>>>> 07483842fa517c05a8c4e2a332271d9be85b897e
